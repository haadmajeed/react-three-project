import { useEffect, useRef } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { RectAreaLightUniformsLib } from "three/examples/jsm/lights/RectAreaLightUniformsLib.js";

function ModelViewer() {
  const canvasRef = useRef(null);
  const speed = 0.01;
  const speedRef = useRef(speed);
  const isPausedRef = useRef(false);
  
  useEffect(() => {
    const canvas = canvasRef.current;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, -30);

    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const path = "https://threejs.org/examples/textures/cube/MilkyWay/";
    const format = ".jpg";
    const urls = [
      path + "dark-s_px" + format,
      path + "dark-s_nx" + format,
      path + "dark-s_py" + format,
      path + "dark-s_ny" + format,
      path + "dark-s_pz" + format,
      path + "dark-s_nz" + format,
    ];
    const cubeTextureLoader = new THREE.CubeTextureLoader();
    const envMap = cubeTextureLoader.load(urls);

    scene.environment = envMap;
    scene.background = envMap;

    RectAreaLightUniformsLib.init();

    const sphereGeometry = new THREE.SphereGeometry(4, 64, 64);
    const sphereMaterial = new THREE.MeshStandardMaterial({
      roughness: 1,
      metalness: 0,
      color: 0x99ccff,
    });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.rotation.x = Math.PI / 2;
    sphere.position.y = -4;
    sphere.receiveShadow = true;
    scene.add(sphere);

    const starGeometry = new THREE.SphereGeometry(12, 32, 32);
    const starMaterial = new THREE.MeshStandardMaterial({
      color: "yellow",
      emissive: new THREE.Color(0xffff00),
      emissiveIntensity: 1.5,
      metalness: 0.7,
      roughness: 0.1,
    });
    const star = new THREE.Mesh(starGeometry, starMaterial);
    star.scale.set(1, 1, 1);
    star.position.set(0, 0, 40);
    star.castShadow = true;
    star.receiveShadow = true;
    scene.add(star);

    const spotLight1 = new THREE.SpotLight("yellow", 3);
    spotLight1.angle = Math.PI / 10;
    spotLight1.power = 12000;
    spotLight1.distance = 40;
    spotLight1.castShadow = true;
    spotLight1.shadow.bias = -0.001;
    spotLight1.shadow.mapSize.width = 2048;
    spotLight1.shadow.mapSize.height = 2048;
    scene.add(spotLight1);
    scene.add(spotLight1.target);
    spotLight1.target.position.copy(sphere.position);

    const loader = new GLTFLoader();

    let model;
    let rectLight;

    loader.load(
      "https://modelviewer.dev/shared-assets/models/Astronaut.glb",
      (gltf) => {
        model = gltf.scene;
        model.scale.setScalar(1.4);

        model.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;

            if (node.material) {
              if (node.material.color) {
                node.material.color.set("white");
              }
              node.material.envMap = envMap;
              node.material.metalness = 0.5;
              node.material.roughness = 0.3;
              node.material.needsUpdate = true;
            }
          }
        });

        model.position.set(0, 0, 0);
        scene.add(model);
      },
      (xhr) => {
        console.log(`Loading model: ${(xhr.loaded / xhr.total) * 100}% loaded`);
      },
      (error) => {
        console.error("Error loading model:", error);
      }
    );

    const orbitRadius = 20;
    let angle = 0;

    const animate = () => {
      requestAnimationFrame(animate);

      if (model && !isPausedRef.current) {
        model.rotation.y -= 0.015;

        angle += speedRef.current;

        star.position.x = model.position.x + 100 * Math.cos(angle);
        star.position.z = model.position.z + 100 * Math.sin(angle);
        star.position.y = model.position.y - 4;

        spotLight1.position.set(
          sphere.position.x + orbitRadius * Math.cos(angle),
          sphere.position.y + 10,
          sphere.position.z + orbitRadius * Math.sin(angle)
        );

        spotLight1.target.position.copy(sphere.position);
        spotLight1.target.updateMatrixWorld();

        if (rectLight) {
          rectLight.lookAt(model.position);
        }
      }

      controls.update();
      renderer.render(scene, camera);
    };

    animate();

    const onResize = () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    };
    window.addEventListener("resize", onResize);

    return () => {
      window.removeEventListener("resize", onResize);
      controls.dispose();
      renderer.dispose();
    };
  }, []);

  return (
    <>
      <button
        onClick={() => {
          isPausedRef.current = !isPausedRef.current;
        }}
        className="mb-2 p-2 bg-gray-700 text-white rounded"
      >
        {isPausedRef.current ? "Resume" : "Pause"}
      </button>
      <canvas
        ref={canvasRef}
        className="w-[90vw] h-[70vh] rounded-lg border-4 border-gray-300 shadow-lg"
      />
    </>
  );
}

export default ModelViewer;
