import { useEffect, useRef } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { RectAreaLightHelper } from "three/examples/jsm/helpers/RectAreaLightHelper.js";
import { RectAreaLightUniformsLib } from "three/examples/jsm/lights/RectAreaLightUniformsLib.js";
import Spotlight from "../lighting/Spotlight";

function ModelViewer() {
    const canvasRef = useRef(null);

    useEffect(() => {
        const canvas = canvasRef.current;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 2, 5);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // // Init RectAreaLight Uniforms
        // RectAreaLightUniformsLib.init();

        // RectAreaLight (soft cinematic light)
        // const rectLight = new THREE.RectAreaLight(0xffa95c, 15, 4, 2);
        // rectLight.position.set(3, 5, 2);
        // rectLight.lookAt(0, 1, 0);
        // scene.add(rectLight);



        const spotLight = new THREE.SpotLight("white", 3);
        spotLight.position.set(0, 4, 0);
        spotLight.angle = Math.PI / 6;
        spotLight.power = 2400;
        spotLight.distance = 10;
        spotLight.castShadow = true;
        spotLight.target.position.set(0, -4, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        // Directional light for additional shadows and fill
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = 0;
        plane.receiveShadow = true;
        scene.add(plane);

        // GLTF Loader
        const loader = new GLTFLoader();

        let model;
        loader.load(
            "https://modelviewer.dev/shared-assets/models/Astronaut.glb",
            (gltf) => {
                model = gltf.scene;
                model.scale.setScalar(1);

                model.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        node.material.color.set("white")
                    }
                    // //change material
                    // node.material = new THREE.MeshStandardMaterial({
                    //     color: "white",
                    //     metalness: 1,
                    //     roughness: 1
                    // })

                });

                model.position.set(0, 0, 0);
                scene.add(model);
            },
            (xhr) => {
                console.log(`Loading model: ${(xhr.loaded / xhr.total) * 100}% loaded`);
            },
            (error) => {
                console.error("Error loading model:", error);
            }
        );

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);

            if (model) {
                model.rotation.y += 0.005;
            }

            controls.update();
            renderer.render(scene, camera);
        };

        animate();

        // Handle resize
        const onResize = () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        };
        window.addEventListener("resize", onResize);

        // Cleanup
        return () => {
            window.removeEventListener("resize", onResize);
            controls.dispose();
            renderer.dispose();
        };
    }, []);

    return (
        <canvas
            ref={canvasRef}
            className="w-[90vw] h-[70vh] rounded-lg border-4 border-gray-300 shadow-lg"
        />
    );
}

export default ModelViewer;
